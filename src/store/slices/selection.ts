/**
 * Selection Slice - Unified element selection state
 *
 * Supports:
 * - Single element selection (component focus)
 * - Multi-selection
 * - Deep selection (granular sub-element selection)
 * - Hover/focus tracking
 */
import type { UIElement } from "@onegenui/core";
import type { SliceCreator } from "../types";

// ─────────────────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Deep selection info - represents a selected sub-element (SERIALIZABLE)
 *
 * This is the canonical type for selection data stored in Zustand.
 * It contains ONLY serializable data - no DOM references.
 *
 * For DOM access, use DeepSelectionInfoWithElement from contexts/selection/types.ts
 * which extends this type with an optional `element` property.
 */
export interface DeepSelectionInfo {
  /** Unique ID for this selection (store-generated) */
  id: string;
  /** The parent component's element key */
  elementKey: string;
  /** CSS path from component root to the selected element */
  cssPath: string;
  /** Tag name of the selected element */
  tagName: string;
  /** Text content (truncated) for AI context */
  textContent: string;
  /** The containing item's data (if selection is within a selectable-item) */
  containingItem?: Record<string, unknown>;
  /** The index of the item in the parent array */
  itemIndex?: number;
  /** The item's unique ID (from data-item-id attribute) */
  itemId?: string;
  /** Type of selection: 'item' for full item, 'granular' for specific text */
  selectionType: "item" | "granular";
  /** Timestamp of selection */
  timestamp: number;
}

/**
 * Input type for creating a new selection.
 * id and timestamp are generated by the store.
 */
export type DeepSelectionInput = Omit<DeepSelectionInfo, "id" | "timestamp">;

// ─────────────────────────────────────────────────────────────────────────────
// Slice Interface
// ─────────────────────────────────────────────────────────────────────────────

export interface SelectionSlice {
  // ─────────────────────────────────────────────────────────────────────────
  // Single selection (component level focus)
  // ─────────────────────────────────────────────────────────────────────────
  selectedKey: string | null;
  selectedElement: UIElement | null;
  select: (key: string | null, element: UIElement | null) => void;
  clearSelection: () => void;

  // ─────────────────────────────────────────────────────────────────────────
  // Multi-selection (component level)
  // ─────────────────────────────────────────────────────────────────────────
  multiSelectedKeys: Set<string>;
  addToMultiSelection: (key: string) => void;
  removeFromMultiSelection: (key: string) => void;
  toggleMultiSelection: (key: string) => void;
  clearMultiSelection: () => void;
  isMultiSelected: (key: string) => boolean;

  // ─────────────────────────────────────────────────────────────────────────
  // Deep selection (sub-element level)
  // ─────────────────────────────────────────────────────────────────────────
  deepSelections: DeepSelectionInfo[];
  deepSelectionActive: boolean;

  addDeepSelection: (selection: DeepSelectionInput) => string;
  removeDeepSelection: (id: string) => void;
  removeDeepSelectionByElement: (elementKey: string, cssPath: string) => void;
  clearDeepSelections: () => void;
  clearDeepSelectionsForElement: (elementKey: string) => void;

  isDeepSelected: (elementKey: string, cssPath: string) => boolean;
  getDeepSelectionsForElement: (elementKey: string) => DeepSelectionInfo[];

  setDeepSelectionActive: (active: boolean) => void;

  // Derived: flat selection map for component API
  getGranularSelection: () => Record<string, Set<string>>;

  // ─────────────────────────────────────────────────────────────────────────
  // Hover state
  // ─────────────────────────────────────────────────────────────────────────
  hoveredKey: string | null;
  setHoveredKey: (key: string | null) => void;

  // ─────────────────────────────────────────────────────────────────────────
  // Focus state
  // ─────────────────────────────────────────────────────────────────────────
  focusedKey: string | null;
  setFocusedKey: (key: string | null) => void;
}

// ─────────────────────────────────────────────────────────────────────────────
// Slice Implementation
// ─────────────────────────────────────────────────────────────────────────────

let selectionIdCounter = 0;
const generateSelectionId = () => `sel_${++selectionIdCounter}_${Date.now()}`;

export const createSelectionSlice: SliceCreator<SelectionSlice> = (
  set,
  get,
) => ({
  // ─────────────────────────────────────────────────────────────────────────
  // Single selection
  // ─────────────────────────────────────────────────────────────────────────
  selectedKey: null,
  selectedElement: null,
  select: (key, element) => set({ selectedKey: key, selectedElement: element }),
  clearSelection: () => set({ selectedKey: null, selectedElement: null }),

  // ─────────────────────────────────────────────────────────────────────────
  // Multi-selection
  // ─────────────────────────────────────────────────────────────────────────
  multiSelectedKeys: new Set(),
  addToMultiSelection: (key) =>
    set((state) => {
      state.multiSelectedKeys.add(key);
    }),
  removeFromMultiSelection: (key) =>
    set((state) => {
      state.multiSelectedKeys.delete(key);
    }),
  toggleMultiSelection: (key) => {
    const { multiSelectedKeys } = get();
    if (multiSelectedKeys.has(key)) {
      get().removeFromMultiSelection(key);
    } else {
      get().addToMultiSelection(key);
    }
  },
  clearMultiSelection: () => set({ multiSelectedKeys: new Set() }),
  isMultiSelected: (key) => get().multiSelectedKeys.has(key),

  // ─────────────────────────────────────────────────────────────────────────
  // Deep selection
  // ─────────────────────────────────────────────────────────────────────────
  deepSelections: [],
  deepSelectionActive: false,

  addDeepSelection: (selection) => {
    const id = generateSelectionId();
    set((state) => {
      state.deepSelections.push({ ...selection, id, timestamp: Date.now() });
    });
    return id;
  },

  removeDeepSelection: (id) =>
    set((state) => {
      state.deepSelections = state.deepSelections.filter((s) => s.id !== id);
    }),

  removeDeepSelectionByElement: (elementKey, cssPath) =>
    set((state) => {
      state.deepSelections = state.deepSelections.filter(
        (s) => !(s.elementKey === elementKey && s.cssPath === cssPath),
      );
    }),

  clearDeepSelections: () => set({ deepSelections: [] }),

  clearDeepSelectionsForElement: (elementKey) =>
    set((state) => {
      state.deepSelections = state.deepSelections.filter(
        (s) => s.elementKey !== elementKey,
      );
    }),

  isDeepSelected: (elementKey, cssPath) => {
    return get().deepSelections.some(
      (s) => s.elementKey === elementKey && s.cssPath === cssPath,
    );
  },

  getDeepSelectionsForElement: (elementKey) => {
    return get().deepSelections.filter((s) => s.elementKey === elementKey);
  },

  setDeepSelectionActive: (active) => {
    set({ deepSelectionActive: active });
    // Auto-reset after 100ms (prevents component-level selection during deep selection)
    if (active) {
      setTimeout(() => {
        set({ deepSelectionActive: false });
      }, 100);
    }
  },

  // Derived state: flat selection map for component API
  getGranularSelection: () => {
    const result: Record<string, Set<string>> = {};
    for (const sel of get().deepSelections) {
      if (sel.itemId) {
        if (!result[sel.elementKey]) {
          result[sel.elementKey] = new Set();
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        result[sel.elementKey]!.add(sel.itemId);
      }
    }
    return result;
  },

  // ─────────────────────────────────────────────────────────────────────────
  // Hover
  // ─────────────────────────────────────────────────────────────────────────
  hoveredKey: null,
  setHoveredKey: (hoveredKey) => set({ hoveredKey }),

  // ─────────────────────────────────────────────────────────────────────────
  // Focus
  // ─────────────────────────────────────────────────────────────────────────
  focusedKey: null,
  setFocusedKey: (focusedKey) => set({ focusedKey }),
});
